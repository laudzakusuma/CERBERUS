// ADVANCED_MONITOR.JS - FIXED VERSION
const { ethers } = require('ethers');
const fetch = require('node-fetch');
const EventEmitter = require('events');
const fs = require('fs').promises;
const path = require('path');
const dotenv = require('dotenv');

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

const CONFIG = {
    U2U_RPC_HTTP: 'https://rpc-nebulas-testnet.uniultra.xyz',
    AI_API_URL: process.env.AI_API_URL || 'http://127.0.0.1:5001/predict',
    MONITOR_PRIVATE_KEY: process.env.MONITOR_PRIVATE_KEY,
    CONTRACT_ADDRESS: process.env.CONTRACT_ADDRESS,
    POLLING_INTERVAL: 3000,
    BATCH_SIZE: 10,
    ALERT_COOLDOWN: 30000,
    MIN_VALUE_THRESHOLD: 0.0001,
    MIN_GAS_THRESHOLD: 30
};

const CONTRACT_ABI = [
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_txHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "_flaggedAddress",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "_relatedAddresses",
          "type": "address[]"
        },
        {
          "internalType": "enum CerberusAdvanced.ThreatLevel",
          "name": "_level",
          "type": "uint8"
        },
        {
          "internalType": "enum CerberusAdvanced.ThreatCategory",
          "name": "_category",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "_confidenceScore",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_severityScore",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "_description",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "_additionalData",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "_modelHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_economicImpact",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "_relatedAlerts",
          "type": "bytes32[]"
        }
      ],
      "name": "reportAdvancedThreat",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "alertId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "txHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "flaggedAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum CerberusAdvanced.ThreatLevel",
          "name": "level",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "enum CerberusAdvanced.ThreatCategory",
          "name": "category",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "confidenceScore",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "reporter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "modelHash",
          "type": "bytes32"
        }
      ],
      "name": "ThreatReported",
      "type": "event"
    }
];

class ThreatAnalyzer extends EventEmitter {
    constructor() { 
        super(); 
        this.alertCooldowns = new Map(); 
    }
    
    analyzeThreat(txData, aiAnalysis) {
        const riskScore = aiAnalysis.danger_score || 0;
        
        // LOWER THRESHOLD FOR TESTING
        const shouldAlert = riskScore > 40 && (aiAnalysis.is_malicious || riskScore > 50);
        
        return { 
            txData, 
            aiAnalysis, 
            riskScore, 
            severity: this.getSeverity(riskScore), 
            shouldAlert  // Now triggers at > 40 instead of > 70
        };
    }
    
    getSeverity(riskScore) { 
        if (riskScore > 90) return 3; 
        if (riskScore > 75) return 2; 
        if (riskScore > 50) return 1; 
        return 0; 
    }
    
    canAlert(txHash) {
        const lastAlert = this.alertCooldowns.get(txHash);
        if (!lastAlert || Date.now() - lastAlert > CONFIG.ALERT_COOLDOWN) { 
            this.alertCooldowns.set(txHash, Date.now()); 
            return true; 
        }
        return false;
    }
}

class CerberusMonitor {
    constructor() {
        this.analyzer = new ThreatAnalyzer();
        this.isRunning = false;
        this.processedTxs = new Set();
        this.stats = { 
            startTime: Date.now(), 
            totalAnalyzed: 0, 
            threatsDetected: 0, 
            alertsSent: 0, 
            errors: 0, 
            lastBlock: 0 
        };
    }

    async initialize() {
        console.log('\nüöÄ INITIALIZING CERBERUS MONITOR'); 
        console.log('='.repeat(50));
        
        if (!CONFIG.MONITOR_PRIVATE_KEY || CONFIG.MONITOR_PRIVATE_KEY === 'MONITOR_PRIVATE_KEY') {
            throw new Error('MONITOR_PRIVATE_KEY not configured in .env file');
        }
        
        this.provider = new ethers.JsonRpcProvider(CONFIG.U2U_RPC_HTTP);
        this.wallet = new ethers.Wallet(CONFIG.MONITOR_PRIVATE_KEY, this.provider);
        this.contract = new ethers.Contract(CONFIG.CONTRACT_ADDRESS, CONTRACT_ABI, this.wallet);
        
        const [blockNumber, balance, contractCode] = await Promise.all([
            this.provider.getBlockNumber(), 
            this.provider.getBalance(this.wallet.address), 
            this.provider.getCode(CONFIG.CONTRACT_ADDRESS)
        ]);
        
        if (contractCode === '0x') {
            throw new Error('Contract not deployed at specified address');
        }
        
        console.log('‚úÖ Blockchain Connection Established'); 
        console.log(`üì¶ Current Block: ${blockNumber}`); 
        console.log(`üí≥ Monitor Wallet: ${this.wallet.address}`); 
        console.log(`üí∞ Balance: ${ethers.formatEther(balance)} U2U`); 
        console.log(`üìú Contract: ${CONFIG.CONTRACT_ADDRESS}`);
        
        await this.testAIConnection();
        this.setupEventListeners();
        this.stats.lastBlock = blockNumber;
        
        console.log('='.repeat(50)); 
        console.log('‚ú® Monitor Ready!\n');
    }

    async testAIConnection() {
        try {
            console.log('\nü§ñ Testing AI Sentinel...');
            const response = await fetch(CONFIG.AI_API_URL.replace('/predict', '/'));
            if (response.ok) {
                const data = await response.json();
                console.log(`‚úÖ AI Sentinel: active`);
                console.log(`   Version: ${data.version || 'v2.0.0-advanced'}`);
                console.log(`   Model: ${data.isolation_model_loaded ? 'Loaded' : 'Not loaded'}`);
            } else { 
                console.warn('‚ö†Ô∏è  AI Sentinel not responding properly'); 
            }
        } catch (error) { 
            console.warn('‚ö†Ô∏è  AI Sentinel offline - using fallback detection'); 
        }
    }

    setupEventListeners() {
        process.on('SIGINT', () => this.shutdown());
        process.on('SIGTERM', () => this.shutdown());
    }

    async start() {
        if (this.isRunning) return;
        console.log('üîÑ Starting monitoring loop...\n');
        this.isRunning = true;
        
        while (this.isRunning) {
            try {
                const currentBlock = await this.provider.getBlockNumber();
                if (currentBlock > this.stats.lastBlock) {
                    const lastProcessedBlock = await this.processBlocks(this.stats.lastBlock + 1, currentBlock);
                    this.stats.lastBlock = lastProcessedBlock;
                }
                await this.sleep(CONFIG.POLLING_INTERVAL);
            } catch (error) {
                console.error('‚ùå Monitoring loop error:', error.message); 
                this.stats.errors++; 
                await this.sleep(CONFIG.POLLING_INTERVAL * 2);
            }
        }
    }

    async processBlocks(startBlock, endBlock) {
        const blockCount = Math.min(endBlock - startBlock + 1, CONFIG.BATCH_SIZE);
        const lastBlockToProcess = startBlock + blockCount - 1;
        
        for (let blockNum = startBlock; blockNum <= lastBlockToProcess; blockNum++) {
            await this.processBlock(blockNum);
        }
        return lastBlockToProcess;
    }

    async processBlock(blockNumber) {
        try {
            const block = await this.provider.getBlock(blockNumber, true);
            if (!block || !block.prefetchedTransactions || block.prefetchedTransactions.length === 0) return;
            
            console.log(`üì¶ Processing block ${blockNumber} with ${block.prefetchedTransactions.length} transactions`);
            
            for (const tx of block.prefetchedTransactions) {
                if (!this.processedTxs.has(tx.hash)) { 
                    await this.analyzeTransaction(tx); 
                    this.processedTxs.add(tx.hash); 
                }
            }
        } catch (error) { 
            console.error(`Error processing block ${blockNumber}:`, error.message); 
        }
    }

    async analyzeTransaction(tx) {
        if (!tx || !tx.hash) { 
            console.log('   ‚è© Skipping transaction with no hash.'); 
            return; 
        }
        
        try {
            const txData = { 
                hash: tx.hash, 
                from: tx.from, 
                to: tx.to, 
                value: tx.value.toString(), 
                gasPrice: tx.gasPrice.toString(), 
                data: tx.data, 
                nonce: tx.nonce 
            };
            
            const gasPrice = parseFloat(ethers.formatUnits(txData.gasPrice, 'gwei'));
            const value = parseFloat(ethers.formatEther(txData.value));
            
            if (value < CONFIG.MIN_VALUE_THRESHOLD && gasPrice < CONFIG.MIN_GAS_THRESHOLD && txData.to) return;

            console.log(`   üîç Analyzing: ${tx.hash.substring(0, 10)}... | From: ${tx.from.substring(0,10)}...`);
            this.stats.totalAnalyzed++;
            
            const aiAnalysis = await this.getAIAnalysis(txData);
            console.log(`      -> üìä AI Response:`, JSON.stringify(aiAnalysis, null, 2));
            
            const threat = this.analyzer.analyzeThreat(txData, aiAnalysis);
            
            if (gasPrice > 100) {  // If gas > 100 gwei
                threat.riskScore = 85;  // Force high risk
                threat.shouldAlert = true;
                aiAnalysis.is_malicious = true;
                aiAnalysis.threat_signature = "FORCED: High Gas Price Attack";
                console.log(`      -> ‚ö†Ô∏è OVERRIDE: Forcing alert for high gas (${gasPrice} gwei)`);
            }
            
            console.log(`      -> üìä Risk: ${threat.riskScore.toFixed(1)} | Malicious: ${threat.shouldAlert ? 'üö® YES' : '‚úÖ NO'}`);
            
            if (threat.shouldAlert && this.analyzer.canAlert(txData.hash)) {
                console.log(`      -> üö® THREAT DETECTED! Signature: ${aiAnalysis.threat_signature}`); 
                this.stats.threatsDetected++; 
                await this.sendOnChainAlert(threat);
            }
        } catch (error) { 
            console.error(`‚ùå Error analyzing tx ${tx.hash}:`, error.message); 
            this.stats.errors++; 
        }
    }

    async getAIAnalysis(txData) {
        try {
            const response = await fetch(CONFIG.AI_API_URL, { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify(txData) 
            });
            if (response.ok) return await response.json();
        } catch (error) { 
            /* Fallback below */ 
        }
        return { 
            danger_score: 0, 
            is_malicious: false, 
            threat_signature: 'FALLBACK: AI unreachable' 
        };
    }

    // FIXED: Generate valid 32-byte hash
    generateValidHash(inputString) {
        const crypto = require('crypto');
        return '0x' + crypto.createHash('sha256').update(inputString).digest('hex');
    }

    async sendOnChainAlert(threat) {
        try {
            const { txData, aiAnalysis, severity, riskScore } = threat;
            console.log('      -> ‚õìÔ∏è  Sending on-chain alert...');
            
            // FIXED: Generate valid 32-byte hash if needed
            let validHash = txData.hash;
            if (txData.hash.startsWith('0xtest')) {
                validHash = this.generateValidHash(txData.hash + Date.now());
                console.log(`      -> üîß Generated valid hash: ${validHash}`);
            }
            
            const params = [ 
                validHash,  // Use valid hash
                txData.from, 
                [], 
                severity, 
                0, 
                Math.floor(aiAnalysis.confidence || 80), 
                Math.floor(riskScore), 
                aiAnalysis.threat_signature.substring(0, 100), 
                '0x', 
                ethers.keccak256(ethers.toUtf8Bytes("cerberus-v2")), 
                0, 
                [] 
            ];
            
            const tx = await this.contract.reportAdvancedThreat(...params, { 
                value: ethers.parseEther("0.01"), 
                gasLimit: 500000 
            });
            
            console.log(`      -> ‚úÖ Alert sent! Tx: ${tx.hash.substring(0,12)}...`);
            this.stats.alertsSent++;
            
            // Wait for confirmation
            await tx.wait();
            console.log(`      -> ‚ö° Alert confirmed on-chain!`);
            
        } catch (error) {
            if (error.message.includes('already reported')) {
                console.log('      -> ‚ö†Ô∏è  Transaction already reported.');
            } else {
                console.error('      -> ‚ùå On-chain alert failed:', error.message);
            }
        }
    }

    printStats() {
        const uptime = Math.floor((Date.now() - this.stats.startTime) / 1000);
        console.log(`\nüìä STATS: Uptime: ${uptime}s | Analyzed: ${this.stats.totalAnalyzed} | Threats: ${this.stats.threatsDetected} | Alerts: ${this.stats.alertsSent} | Errors: ${this.stats.errors}\n`);
    }

    async shutdown() {
        if (!this.isRunning) return;
        console.log('\n\nüõë Shutting down monitor...'); 
        this.isRunning = false;
        this.printStats();
        
        try {
            await fs.writeFile(path.join(__dirname, 'monitor_state.json'), JSON.stringify({ 
                stats: this.stats, 
                timestamp: Date.now() 
            }, null, 2));
            console.log('üíæ State saved');
        } catch (error) { 
            console.error('Failed to save state:', error.message); 
        }
        
        console.log('‚úÖ Monitor shutdown complete');
        process.exit(0);
    }
    
    sleep(ms) { 
        return new Promise(resolve => setTimeout(resolve, ms)); 
    }
}

async function main() {
    const monitor = new CerberusMonitor();
    try {
        await monitor.initialize();

        console.log("\nüî• FORCING TEST TRANSACTION");
        const testTx = {
            hash: '0x' + require('crypto').createHash('sha256').update('test_' + Date.now()).digest('hex'),  // FIXED: Valid 32-byte hash
            from: '0xfe89f390C1cf3D6b83171D41bEEF4A3E3A763fAE',
            to: null, // Contract creation
            value: ethers.parseEther('10').toString(),
            gasPrice: ethers.parseUnits('150', 'gwei').toString(),
            gasLimit: '500000',
            data: '0x60806040',
            nonce: 1
        };
        await monitor.analyzeTransaction(testTx);
        console.log("üî• TEST COMPLETE\n");
        
        // Start real monitoring
        await monitor.start();
        
    } catch (error) {
        console.error('FATAL:', error.message); 
        process.exit(1);
    }
}

// This prevents the script from exiting prematurely.
process.stdin.resume();
main();